# 9장 유연한 설계

## 개방-폐쇄 원칙


: 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

- 앱의 요구사항이 변경될 때, 이 변경에 맞게 새로운 동작을 추가해서 앱의 기능을 `확장`할 수 있다.
- 기존의 코드를 `수정하지 않고` 앱의 동작을 추가하거나 변경할 수 있다.

→ **추상화에 의존하는 것**이 이 원칙의 핵심

- 상속을 통해 기능을 확장할 수 있음
- 상속받아 기능을 추가하기 때문에 기존 코드를 수정하지 않음

## 생성 사용 분리

추상화에만 의존하기 위해서는 사용하는 클래스 내부에서 인스턴스를 생성하면 안됨 → 구체 클래스로 생성해야 하기 때문

### Factory 패턴


: 객체 생성과 관련된 책임만 전담하는 별도의 객체를 사용하는 패턴

- 이전에 객체를 생성하는 책임은 그 객체에 대해서 가장 잘 아는 INFORMATION EXPERT 객체에게 책임을 할당하라고 했으나, FACTORY는 이에 맞지 않음

→ 책임을 할당할 마땅한 도메인 객체가 없다면 PURE FABRICATION 객체를 사용

- 대표적으로 FACTORY

## 의존성 주입


: 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법

### 방법

- 생성자 주입 : 객체를 생성하는 시점에 생성자를 통한 해결
- setter 주입 : 객체 생성 후 setter 메서드를 통한 해결
- 메서드 주입 : 메서드 실행 시 인자를 이용한 해결

+) Hilt는 public 멤버도 주입이 되지 않나? 이거 생성자로 넣는거였나 기억이 안나네

### SERVICE LOCATOR 패턴


: 의존성을 해결할 객체들을 보관하는 일종의 저장소

- 객체가 직접 SERVICE LOCATOR에게 의존성 해결을 요청함
- 단점 : 의존성을 감추고 있어서 캡슐화 위반

- 접근해야 할 객체가 있을 때는 전역 보다는 받을 수 있는지부터 확인

## 의존성 역전 원칙

상위 클래스가 하위 클래스의 구현에 영향을 받는다면 문제가 생길 수 있음

→ 추상화로 해결할 수 있음

- 인터페이스와 구체 클래스의 모듈을 분리시켜서 상위 클래스가 하위 구체 클래스들을 접근하지 못하게 구조를 변경