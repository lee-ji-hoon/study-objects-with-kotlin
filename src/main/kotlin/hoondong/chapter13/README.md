# 13장 서브클래싱과 서브타이핑

### 상속의 용도

- 타입 계층을 구현하는 것
- 코드 재사용

코드 재사용이 우선시되어서는 안됨

## 타입

인스턴스(객체) : 어떤 타입에 분류되는 대상

심볼 : 타입에 이름을 붙인 것

내연(Intension) : 타입에 속하는 객체들이 가지는 공통적인 속성

외연(Extension) : 타입에 속하는 객체들의 집합

### 타입의 목적

- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공

⇒ 적용 가능한 연산자의 종류를 제한해 실수 방지

- 퍼블릭 인터페이스를 이용하여 객체가 수신할 수 있는 메시지를 정의함

객체에게 중요한 것은 속성이 아니라 행동

객체가 외부에 제공하는 행동이 객체의 타입을 결정

## 타입 계층

두 타입 간의 관계에서 더 일반적인 타입을 **슈퍼타입**

더 특수한 타입을 **서브타입**

- 슈퍼타입
    - 집합이 다른 집합의 모든 멤버를 포함
    - 타입 정의가 다른 타입보다 더 일반적
- 서브타입
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함
    - 타입 정의가 다른 타입보다 더 구체적

일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준

: **퍼블릭 인터페이스**

## 서브클래싱과 서브타이핑

### is-a 관계

- 어떤 타입이 다른 타입의 일종인 관계
- 관계를 정의하기 위해서 **행동 호환성**이 중요
- 행동에 연관성이 있어야 상속을 적용할 수 있음

### 인터페이스 분리 원칙


: 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙

- **서브클래싱(구현 상속, 클래스 상속)** : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
    - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스 대체 불가능
- **서브타이핑(인터페이스 상속)** : 타입 계층을 구성하기 위해 상속을 사용하는 경우
    - 자식 클래스의 인스턴스가 부모 클래스의 인스턴스 대체 가능

- 행동 호환성은 부모 클래스에 대한 자식 클래스의 **대체 가능성**을 포함

## 리스코프 치환 원칙

- 원칙을 지키고 있다면 서브타이핑 관계
- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 함

## 계약에 의한 설계


: 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것

- 구성요소
    - 사전조건 : 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 조건
    - 사후조건 : 메서드가 실행된 후에 서버가 클라이언트에게 보장해야 하는 조건
    - 클래스 불변식 : 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 조건

- 서브타입에는 더 강력한 사전조건을 정의할 수 없음
- 서브타입에는 더 약한 사후조건을 정의할 수 없음