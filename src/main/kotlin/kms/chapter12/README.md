### 다형성

> 그리스어 `많은(ploy)` -  `형태(morph)` 의 합성어

- 상속의 목적은 **코드 재사용이 아니다**
	- 재사용을 위해 상속을 사용하면 유지보수하기 어려운 코드가 만들어질 확률이 높다
- 타입 계층을 **구조화**하기 위해 사용

![](https://i.imgur.com/zOPVSvl.png)

- 오버로딩 다형성
	- 하나의 클래스 안에서 동일한 이름의 메서드가 존재하는 경우
- 강제 다형성
	- 언어가 지원하는 자동 타입변환이나 사용자가 직접 구현한 타입변환을 이용해 동일한 연사자를 다양한 타입에 사용하는 방식
	- ex) `+` 를 이용한 **정수** 연산과 **문자열** 연산
	- 오버로딩 다형성과 강제 다형성을 동시에 사용하면 코드가 모호해질 수 있다
- 매개변수 다형성
	- **제네릭 프로그래밍**과 관련이 높다
- 포함 다형성
	- **서브타입 다형성**이라 불린다
	- 메시지가 동일해도 수신한 객체의 타입에 따라 실제로 수행 되는 행동이 달라진다
	- 자식이 부모의 메서드를 오버라이드 했을때 각각 객체가 수행하는 행동이 다르다

>[!note] 객체지향 패러다임의 근간
>데이터와 행동을 **객체**라고 불리는 하나의 실행 단위 안으로 통합하는 것

### 상속 메커니즘의 개념

- 업캐스팅
	- 부모타입으로 선언된 변수에 자식 클래스를 할당하는 것
- 다운 캐스팅
	- 부모 클래스의 인스턴스를 자식 클래스의 타입으로 변환
- 동적 메서드 탐색
	- 자신을 생성한 클래스에 메서드가 존재하는지 검사한다
	- 메서드를 찾지 못하면 부모  클래스를 탐색하며 찾을 때까지 상위 계층으로 올라간다
	- 최상위 클래스에서도 찾지 못하면 예외를 발생하며 탐색을 중단한다
- 동적 바인딩 (=지연 바인딩)
	- 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행 메서드가 결정됨
	- 메시지를 수신하는 런타임에 결정 된다
- self 참조
	- 객체가 메시지를 수신하면 컴파일러가 self 참조 라는 임시 변수를 생성
	- 메서드 탐색이 종료되면 소멸한다
	- class 포인터, parent 포인터, self 참조를 조합하여 탐색한다
	- Java 에서는 self 참조를 this 라고 부른다
- super 참조
	- 자식클래스에서 부모클래스의 구현을 재사용해야 하는 경우 접근하기 위해 사용
	- 부모 클래스에 **메시지**를 전송한다
	- 메시지를 탐색을  시작하는 클래스는 미정이지만 super 는 미리 정해지기 때문에 컴파일 시점에 미리 결정된다
- 메서드 오버라이딩
	- 동일한 시그니처를 가진 자식 클래스의 메서드가 부모 클래스의 메서드를 가림
- 메서드 오버로딩
	- 메서드의 이름은 같지만 시그니처가 다른경우
	- 시그니처가 다르기 때문에 대체하지 않고 공존한다
- 위임
	- 자신이 수신한 메시지를 다른 객체에게 전달해서 처리를 요청하는 것

#### 데이터 관점의 상속

- 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함
	- 따라서 자식 클래스의 인스턴스는 자동으로 부모클래스에서 정의한 모든 인스턴스 변수를 포함

#### 행동 관점의 상속

- 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함
- 런타임에 자식 클래스에 정의되지 않은 메서드가 있을 경우 부모 클래스에서 탐색

### 메시지

```java
public class Lecture {
	public String getEvaluationMethod() {
		return "Pass or Fail";
	}
}
```

- Lecture 가 getEvaluationMethod 를 호출한다 ( X )
	- 현재 객체(self) 에게 메시지를 전송한다