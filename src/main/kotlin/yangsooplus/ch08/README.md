## 08 의존성 관리하기

작고 응집도 높은 객체?

책임의 초점이 명확하고 한 가지 일만 잘 하는 객체

➡️ 단독 수행 x. 다른 객체와의 협력이 필수

### 무조건 협력을 많이 할수록 좋을까?
응~ 뇌절 컷~~

협력 -> 객체가 다른 객체의 존재와 메시지를 알고 있어야 함 -> 의존성 up

협력을 위한 의존성을 유지하면서 변경을 방해하는 의존성을 제거해야 한다

### 의존성 이해하기
- 의존성의 두가지 의미
  - 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 존재해야 함
  - 구현 시점: 의존대상 객체가 변경되는 경우 의존하는 객체도 함께 변경된다.
- 방향성을 가지며, 항상 단방향
- 변경에 의한 영향의 전파 가능성을 암시한다. 
  - 어떤 요소 하나가 변경되었을 때, 그 요소에 의존하고 있는 요소도 변경 가능성이 있음
- 의존성 전이 (transitive dependency)
  - A가 B에 의존하고, B가 C에 의존하면 A는 자동적으로 C에 의존하게 됨.
  - 무조건 의존성이 전이되는 것은 아니고, 캡슐화가 잘 되어 있다면 영향 없을수도 있음
- 의존성 != 그 요소를 알고있다 
- 의존성 == 그 요소의 변경에 영향을 받을 수 있는 가능성
- 런타임 의존성과 컴파일 타임 의존성이 다를 수 있다. 

### 의존성 해결
- 컴파일 타임 의존성을 실행 컨텍스트에 적절한 런타임 의존성으로 교체하는 것
- 어케 해결함?
  - 생성자에서
  - setter로
  - 메서드 인자로

## 유연한 설계
- 바람직한 의존성?
  - 특정 클래스에 의존 X
  - 문맥상 메세지를 이해할 수 있고 응답만 한다면 어떤 타입의 객체와 협력해도 노상관
  - 재사용할 수 있는 의존성이 바람직한 의존성이다.
    - 컨텍스트에 독립적인 의존성이 바람직한 의존성.
    - 컨텍스트에 강하게 의존하는 클래스를 재사용하려면? 구현을 변경하는 방법 뿐.
  - 바람직한 의존성은 곧 느슨한 겷합도를 의미

### 지식이 결합을 낳는다
- 알고 있는 정보가 많을수록 강하게 결합
- 구체적인 방법은 알 필요 없음. 최대한 감추자
  - 추상화에 의존함으로서 충족
  - 클래스 > 추상 클래스 > 인터페이스 (느슨~)

### 의존성을 감추는 것을 경계하라
- 의존성을 구현 내부에 숨기지 말고 명시적으로 표현하라.
- 의존성이 명시적이지 않으면 파악하기 위해서는 내부 구현을 다 살펴봐야 함 
  - ex) 특정 메서드나 생성자에서 구체적인 클래스의 인스턴스를 생성한다든지..
- 인스턴스 생성을 잘못된 곳에서 하면 결합도가 극단적으로 높아진다
  - 구체 클래스의 이름을 직접 기술 -> 추상화 X
  - 생성자 호출에 필요한 인자도 알아야 함 -> 결합도 폭발
- 그럼 어케해결해야함? 
  - 인스턴스 생성 로직과 생성된 인스턴스를 사용하는 로직을 분리하라

