# 09 유연한 설계

## OCP 개방-폐쇄 원칙

*확장에 열려있어야 하고, 수정에 닫혀있어야 한다.

### 확장에 열린 것?
- 요구사항이 변경될 때 새로운 동작을 추가해서 기능을 확장

### 수정에 닫힌 것?
- 기존의 코드를 수정하지 않도 동작을 추가하거나 변경

### 어떻게?

- **컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라!**
- 런타임 의존성
  - 실행 시에 협력에 참여하는 **객체** 사이 관계
- 컴파일 의존성
  - 코드에서 드러나는 **클래스** 사이 관계
- OCP를 따르는 코드는? 컴파일 타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조
- 추상화가 핵심
  - 추상화 = 핵심적인 부분만 남기고 불필요한 부분 생략 = 복잡성 Down
  - 문맥만 남기 때문에 생략된 부분을 채워넣어서 기능을 구체화, 확장
  - 그럼 남아야 하는 부분은?
    - 다양한 상황에서의 공통점을 반영한 추상화의 결과물
    - 간단히 말해 변하지 않는 부분
- 본질: 추상화로 **의존성의 방향**을 관리

## 생성 사용 분리

- 가장 보편적인 방법
  - 객체 생성 책임을 클라이언트로 옮기기

### Factory

- 객체 생성에 특화된 Factory를 만들어 객체 생성 관련 책임을 전담시킴
- 표면적 분해
  - 도메인 모델에 담겨 있는 개념과 관계를 따름
  - 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 함
  - 꼭 모든 책임을 도메인 객체에게만 할당해야 할까? 놉!
  - 필요에 따라 인공적인 객체로 책임을 전가 -> Factory 등..

## 의존성 주입

- 외부의 독립적인 객체가 인스턴스를 생성한 후 전달하여 의존생 해결
- Service Locator 패턴의 단점
  - 의존성을 감춘다
  - 숨겨진 의존성 -> 런타임에서만 문제 발견 가능, 단위 테스트 어려움
  - 왜? 캡슐화 위반해서~
  - 클래스 사용법을 익히기 위해 구현 내부를 뒤져야 한다? 캡슐화 안된거다.
- 의존성을 객체의 퍼블릭 인터페이스에 노출시키자.

## 의존성 역전 원칙

- 상위 수준의 클래스는 어떤 식으로든 하위 수준의 클래스에 의존 X
  - 상위의 변경으로 하위가 변경 -> ㄱㅊ
  - 하위 변경으로 상위 변경 -> 누가 이렇게 짰냐?
- 재사용하려는 대상은? 상위 클래스
- 추상화로 해결


## 무조건 유연한게 좋은가?

- 변경은 예상이 아니라 현실이어야 한다.
- 유연성은 복잡성을 낳음
- 미래에 변경이 일어날지도 모른다는 막연한 불안감이 복잡성의 근거가 되면 안된다.

### 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다.